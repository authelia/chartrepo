---
## @formatter:off
## values.local.yaml
##
## Repository: authelia https://charts.authelia.com
## Chart: authelia
##
## This values file is designed for a StatefulSet deployment with a single pod. It is not intended for production environments
## It uses the following providers:
##   - authentication: file (yaml)
##   - storage: local (SQLite3)
##   - session: memory
##   - notification: filesystem (yaml)

## Image Parameters
## ref: https://hub.docker.com/r/authelia/authelia/tags/
##
image:
  registry: ghcr.io
  repository: authelia/authelia
  tag: 4.29.4
  pullPolicy: IfNotPresent
  pullSecrets: []
  # pullSecrets:
  #   - myPullSecretName

# nameOverride: authelia-deployment-name
# appNameOverride: authelia


##
## extra labels/annotations applied to all resources
##
annotations: {}
# annotations:
#   myAnnotation: myValue

labels: {}
# labels:
#   myLabel: myValue

##
## RBAC Configuration.
##
rbac:

  ## Enable RBAC. Turning this on associates Authelia with a service account.
  ## If the vault injector is enabled, then RBAC must be enabled.
  enabled: false

  annotations: {}
  labels: {}

  serviceAccountName: authelia


## Authelia Domain
## Should be the root domain you want to protect.
## For example if you have apps app1.example.com and app2.example.com it should be example.com
## This affects the ingress (partially sets the domain used) and configMap.
## Authelia must be served from the domain or a subdomain under it.
domain: example.com

service:
  annotations: {}
  # annotations:
  #   myAnnotation: myValue

  labels: {}
  # labels:
  #   myLabel: myValue

  port: 80

  # clusterIP:


ingress:
  enabled: false

  annotations: {}
  # annotations:
  #   kubernetes.io/ingress.class: nginx
  #   kubernetes.io/tls-acme: "true"

  labels: {}
  # labels:
  #   myLabel: myValue

  certManager: false
  rewriteTarget: true

  ## The Ingress Class Name.
  # className: ingress-nginx

  ## Subdomain is the only thing required since we specify the domain as part of the root values of the chart.
  ## Example: To get Authelia to listen on https://auth.example.com specify 'auth' for ingress.subdomain,
  ## and specify example.com for the domain.
  subdomain: auth

  tls:
    enabled: true
    secret: authelia-tls

    # hostNameOverride:

  traefikCRD:
    enabled: false

    ## Use a standard Ingress object, not an IngressRoute.
    disableIngressRoute: false

    # matchOverride: Host(`auth.example.com`) && PathPrefix(`/`)

    entryPoints: []
    # entryPoints:
    # - http

    # priority: 10

    # weight: 10

    sticky: false

    # stickyCookieNameOverride: authelia_traefik_lb

    # strategy: RoundRobin

    # responseForwardingFlushInterval: 100ms

    middlewares:
      auth:
        # nameOverride: authelia-auth
        authResponseHeaders:
        - Remote-User
        - Remote-Name
        - Remote-Email
        - Remote-Groups

      chains:
        auth:
          # nameOverride: authelia-auth-chain

          # List of Middlewares to apply before the forwardAuth Middleware in the authentication chain.
          before: []
          # before:
          # - name: extra-middleware-name
          #   namespace: default

          # List of Middlewares to apply after the forwardAuth Middleware in the authentication chain.
          after: []
          # after:
          # - name: extra-middleware-name
          #   namespace: default

        ingressRoute:

          # List of Middlewares to apply before the middleware in the IngressRoute chain.
          before: []
          # before:
          # - name: extra-middleware-name
          #   namespace: default

          # List of Middlewares to apply after the middleware in the IngressRoute chain.
          after: []
          # after:
          # - name: extra-middleware-name
          #   namespace: default

    # Specific options for the TraefikCRD TLS configuration. The above TLS section is still used.
    tls:
      #   existingOptions:
      #     name: default-traefik-options
      #     namespace: default
      #   certResolver: default
      #   sans:
      #     - *.example.com
      #
      options: {}
      #   nameOverride: authelia-tls-options
      #   minVersion: VersionTLS12
      #   maxVersion: VersionTLS13
      #   curvePreferences:
      #   - CurveP521
      #   - CurveP384
      #   cipherSuites:
      #   - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
      #   - TLS_RSA_WITH_AES_256_GCM_SHA384
      #   sniStrict: true

pod:
  # Must be Deployment, DaemonSet, or StatefulSet.
  kind: StatefulSet

  annotations: {}
  # annotations:
  #   myAnnotation: myValue

  labels: {}
  # labels:
  #   myLabel: myValue

  replicas: 1
  revisionHistoryLimit: 5

  updateStrategy: RollingUpdate

  securityContext:
    container: {}
    # container:
    #   runAsUser: 2000
    #   runAsGroup: 2000
    #   fsGroup: 2000
    pod: {}
    # pod:
    #   readOnlyRootFilesystem: true
    #   allowPrivilegeEscalation: false
    #   privileged: false

  tolerations: []
  # tolerations:
  # - key: key1
  #   operator: Equal
  #   value: value1
  #   effect: NoSchedule
  #   tolerationSeconds: 3600

  selectors:
  #   nodeName: worker-1

    nodeSelector: {}
    # nodeSelector:
    #   disktype: ssd
    #   kubernetes.io/hostname: worker-1

    affinity:
      nodeAffinity: {}
      # nodeAffinity:
      #   requiredDuringSchedulingIgnoredDuringExecution:
      #     nodeSelectorTerms:
      #     - matchExpressions:
      #       - key: kubernetes.io/hostname
      #         operator: In
      #         values:
      #         - worker-1
      #         - worker-2
      #   preferredDuringSchedulingIgnoredDuringExecution:
      #   - weight: 1
      #     preference:
      #       matchExpressions:
      #       - key: node-label-key
      #         operator: NotIn
      #         values:
      #         - not-this
      podAffinity: {}
      # podAffinity:
      #   requiredDuringSchedulingIgnoredDuringExecution:
      #   - labelSelector:
      #       matchExpressions:
      #       - key: security
      #         operator: In
      #         values:
      #         - S1
      #     topologyKey: topology.kubernetes.io/zone
      podAntiAffinity: {}
      # podAntiAffinity:
      #     preferredDuringSchedulingIgnoredDuringExecution:
      #     - weight: 100
      #       podAffinityTerm:
      #         labelSelector:
      #           matchExpressions:
      #           - key: security
      #             operator: In
      #             values:
      #             - S2
      #         topologyKey: topology.kubernetes.io/zone

  env: []
  # env:
  # - name: TZ
  #   value: Australia/Melbourne

  resources:
    limits: {}
    # limits:
    #   cpu: "4.00"
    #   memory: 125Mi
    requests: {}
    # requests:
    #   cpu: "0.25"
    #   memory: 50Mi

  probes:
    method:
      httpGet:
        path: /api/health
        port: http
        scheme: HTTP

    liveness:
      initialDelaySeconds: 0
      periodSeconds: 30
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 5

    readiness:
      initialDelaySeconds: 0
      periodSeconds: 5
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 5

    ## Note: Startup Probes are a Kubernetes feature gate which must be manually enabled pre-1.18.
    ## Ref: https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/
    startup:
      initialDelaySeconds: 10
      periodSeconds: 5
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 6

  extraVolumeMounts: []
  extraVolumes: []

##
## Kubernetes Pod Disruption Budget
##
podDisruptionBudget:
  enabled: false

  annotations: {}
  # annotations:
  #   myAnnotation: myValue

  labels: {}
  # labels:
  #   myLabel: myValue

  # minAvailable: 1
  # maxUnavailable: 1

##
## Kubernetes Network Policy
##
networkPolicy:
  enabled: false

  annotations: {}
  # annotations:
  #   myAnnotation: myValue

  labels: {}
  # labels:
  #   myLabel: myValue

  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          authelia.com/network-policy: namespace
    - podSelector:
        matchLabels:
          authelia.com/network-policy: pod
    ports:
    - protocol: TCP
      port: 9091


##
## Authelia Config Map Generator
##
configMap:

  # Enable the configMap source for the Authelia config.
  # If this is false you need to provide a volumeMount via PV/PVC or other means that mounts to /config.
  enabled: true

  annotations: {}
  # annotations:
  #   myAnnotation: myValue

  labels: {}
  # labels:
  #   myLabel: myValue

  key: configuration.yaml

  existingConfigMap: ""

  ##
  ## Port sets the configured port for the daemon, service, and the probes.
  ## Default is 9091 and should not need to be changed.
  ##
  port: 9091

  ##
  ## Server Configuration
  ##
  server:
    ## Buffers usually should be configured to be the same value.
    ## Explanation at https://www.authelia.com/docs/configuration/server.html
    ## Read buffer size adjusts the server's max incoming request size in bytes.
    ## Write buffer size does the same for outgoing responses.
    read_buffer_size: 4096
    write_buffer_size: 4096
    ## Set the single level path Authelia listens on.
    ## Must be alphanumeric chars and should not contain any slashes.
    path: ""

  ## Level of verbosity for logs: info, debug, trace.
  log_level: info
  ## Format the logs are written as: json, text.
  log_format: text
  ## TODO: Statefulness check should check if this is set, and the configMap should enable it.
  ## File path where the logs will be written. If not set logs are written to stdout.
  # log_file_path: /config/authelia.log

  ## Default redirection URL
  ##
  ## If user tries to authenticate without any referer, Authelia does not know where to redirect the user to at the end
  ## of the authentication process. This parameter allows you to specify the default redirection URL Authelia will use
  ## in such a case.
  ##
  ## Note: this parameter is optional. If not provided, user won't be redirected upon successful authentication.
  ## Default is https://www.<domain> (value at the top of the values.yaml).
  default_redirection_url: ""
  # default_redirection_url: https://example.com

  theme: light

  ##
  ## TOTP Configuration
  ##
  ## Parameters used for TOTP generation
  totp:
    ## The issuer name displayed in the Authenticator application of your choice
    ## See: https://github.com/google/google-authenticator/wiki/Key-Uri-Format for more info on issuer names
    ## Defaults to <domain>.
    issuer: ""
    ## The period in seconds a one-time password is current for. Changing this will require all users to register
    ## their TOTP applications again. Warning: before changing period read the docs link below.
    period: 30
    ## The skew controls number of one-time passwords either side of the current one that are valid.
    ## Warning: before changing skew read the docs link below.
    ## See: https://www.authelia.com/docs/configuration/one-time-password.html#period-and-skew to read the documentation.
    skew: 1

  ##
  ## Duo Push API Configuration
  ##
  ## Parameters used to contact the Duo API. Those are generated when you protect an application of type
  ## "Partner Auth API" in the management panel.
  duo_api:
    enabled: false
    hostname: api-123456789.example.com
    integration_key: ABCDEF

  ##
  ## Authentication Backend Provider Configuration
  ##
  ## Used for verifying user passwords and retrieve information such as email address and groups users belong to.
  ##
  ## The available providers are: `file`, `ldap`. You must use one and only one of these providers.
  authentication_backend:
    ## Disable both the HTML element and the API for reset password functionality
    disable_reset_password: false

    ## The amount of time to wait before we refresh data from the authentication backend. Uses duration notation.
    ## To disable this feature set it to 'disable', this will slightly reduce security because for Authelia, users will
    ## always belong to groups they belonged to at the time of login even if they have been removed from them in LDAP.
    ## To force update on every request you can set this to '0' or 'always', this will increase processor demand.
    ## See the below documentation for more information.
    ## Duration Notation docs:  https://www.authelia.com/docs/configuration/index.html#duration-notation-format
    ## Refresh Interval docs: https://www.authelia.com/docs/configuration/authentication/ldap.html#refresh-interval
    refresh_interval: 5m

    ## LDAP backend configuration.
    ##
    ## This backend allows Authelia to be scaled to more
    ## than one instance and therefore is recommended for
    ## production.
    ldap:

      ## Enable LDAP Backend.
      enabled: false

      ## The LDAP implementation, this affects elements like the attribute utilised for resetting a password.
      ## Acceptable options are as follows:
      ## - 'activedirectory' - For Microsoft Active Directory.
      ## - 'custom' - For custom specifications of attributes and filters.
      ## This currently defaults to 'custom' to maintain existing behaviour.
      ##
      ## Depending on the option here certain other values in this section have a default value, notably all of the
      ## attribute mappings have a default value that this config overrides, you can read more about these default values
      ## at https://www.authelia.com/docs/configuration/authentication/ldap.html#defaults
      implementation: activedirectory

      ## The url to the ldap server. Format: <scheme>://<address>[:<port>].
      ## Scheme can be ldap or ldaps in the format (port optional).
      url: ldap://openldap.default.svc.cluster.local

      ## Use StartTLS with the LDAP connection.
      start_tls: false

      tls:
        ## Server Name for certificate validation (in case it's not set correctly in the URL).
        server_name: ""

        ## Skip verifying the server certificate (to allow a self-signed certificate).
        ## In preference to setting this we strongly recommend you add the public portion of the certificate to the
        ## certificates directory which is defined by the `certificates_directory` option at the top of the config.
        skip_verify: false

        ## Minimum TLS version for either Secure LDAP or LDAP StartTLS.
        minimum_version: TLS1.2

      ## The base dn for every LDAP query.
      base_dn: DC=example,DC=com

      ## The attribute holding the username of the user. This attribute is used to populate the username in the session
      ## information. It was introduced due to #561 to handle case insensitive search queries. For you information,
      ## Microsoft Active Directory usually uses 'sAMAccountName' and OpenLDAP usually uses 'uid'. Beware that this
      ## attribute holds the unique identifiers for the users binding the user and the configuration stored in database.
      ## Therefore only single value attributes are allowed and the value must never be changed once attributed to a user
      ## otherwise it would break the configuration for that user. Technically, non-unique attributes like 'mail' can also
      ## be used but we don't recommend using them, we instead advise to use the attributes mentioned above
      ## (sAMAccountName and uid) to follow https://www.ietf.org/rfc/rfc2307.txt.
      username_attribute: ""

      ## An additional dn to define the scope to all users.
      additional_users_dn: OU=Users

      ## The users filter used in search queries to find the user profile based on input filled in login form.
      ## Various placeholders are available in the user filter:
      ## - {input} is a placeholder replaced by what the user inputs in the login form.
      ## - {username_attribute} is a mandatory placeholder replaced by what is configured in `username_attribute`.
      ## - {mail_attribute} is a placeholder replaced by what is configured in `mail_attribute`.
      ## - DON'T USE - {0} is an alias for {input} supported for backward compatibility but it will be deprecated in later
      ##   versions, so please don't use it.
      ##
      ## Recommended settings are as follows:
      ## - Microsoft Active Directory: (&({username_attribute}={input})(objectCategory=person)(objectClass=user))
      ## - OpenLDAP:
      ##   - (&({username_attribute}={input})(objectClass=person))
      ##   - (&({username_attribute}={input})(objectClass=inetOrgPerson))
      ##
      ## To allow sign in both with username and email, one can use a filter like
      ## (&(|({username_attribute}={input})({mail_attribute}={input}))(objectClass=person))
      users_filter: ""

      ## An additional dn to define the scope of groups.
      additional_groups_dn: OU=Groups

      ## The groups filter used in search queries to find the groups of the user.
      ## - {input} is a placeholder replaced by what the user inputs in the login form.
      ## - {username} is a placeholder replace by the username stored in LDAP (based on `username_attribute`).
      ## - {dn} is a matcher replaced by the user distinguished name, aka, user DN.
      ## - {username_attribute} is a placeholder replaced by what is configured in `username_attribute`.
      ## - {mail_attribute} is a placeholder replaced by what is configured in `mail_attribute`.
      ## - DON'T USE - {0} is an alias for {input} supported for backward compatibility but it will be deprecated in later
      ##   versions, so please don't use it.
      ## - DON'T USE - {1} is an alias for {username} supported for backward compatibility but it will be deprecated in
      ##   later version, so please don't use it.
      ##
      ## If your groups use the `groupOfUniqueNames` structure use this instead:
      ##    (&(uniquemember={dn})(objectclass=groupOfUniqueNames))
      groups_filter: ""

      ## The attribute holding the name of the group
      group_name_attribute: ""

      ## The attribute holding the mail address of the user. If multiple email addresses are defined for a user, only the
      ## first one returned by the LDAP server is used.
      mail_attribute: ""

      ## The attribute holding the display name of the user. This will be used to greet an authenticated user.
      display_name_attribute: ""

      ## The username of the admin user.
      user: CN=Authelia,DC=example,DC=com

    ##
    ## File (Authentication Provider)
    ##
    ## With this backend, the users database is stored in a file which is updated when users reset their passwords.
    ## Therefore, this backend is meant to be used in a dev environment and not in production since it prevents Authelia
    ## to be scaled to more than one instance. The options under 'password' have sane defaults, and as it has security
    ## implications it is highly recommended you leave the default values. Before considering changing these settings
    ## please read the docs page below:
    ## https://www.authelia.com/docs/configuration/authentication/file.html#password-hash-algorithm-tuning
    ##
    ## Important: Kubernetes (or HA) users must read https://www.authelia.com/docs/features/statelessness.html
    ##
    file:
      enabled: true
      path: /config/users_database.yml
      password:
        algorithm: sha512
        iterations: 100000
        key_length: 32
        salt_length: 16
        memory: 1024
        parallelism: 8

  ##
  ## Access Control Configuration
  ##
  ## Access control is a list of rules defining the authorizations applied for one resource to users or group of users.
  ##
  ## If 'access_control' is not defined, ACL rules are disabled and the 'bypass' rule is applied, i.e., access is allowed
  ## to anyone. Otherwise restrictions follow the rules defined.
  ##
  ## Note: One can use the wildcard * to match any subdomain.
  ## It must stand at the beginning of the pattern. (example: *.mydomain.com)
  ##
  ## Note: You must put patterns containing wildcards between simple quotes for the YAML to be syntactically correct.
  ##
  ## Definition: A 'rule' is an object with the following keys: 'domain', 'subject', 'policy' and 'resources'.
  ##
  ## - 'domain' defines which domain or set of domains the rule applies to.
  ##
  ## - 'subject' defines the subject to apply authorizations to. This parameter is optional and matching any user if not
  ##    provided. If provided, the parameter represents either a user or a group. It should be of the form
  ##    'user:<username>' or 'group:<groupname>'.
  ##
  ## - 'policy' is the policy to apply to resources. It must be either 'bypass', 'one_factor', 'two_factor' or 'deny'.
  ##
  ## - 'resources' is a list of regular expressions that matches a set of resources to apply the policy to. This parameter
  ##   is optional and matches any resource if not provided.
  ##
  ## Note: the order of the rules is important. The first policy matching (domain, resource, subject) applies.
  access_control:
    ## Default policy can either be 'bypass', 'one_factor', 'two_factor' or 'deny'. It is the policy applied to any
    ## resource if there is no policy to be applied to the user.
    default_policy: deny

    networks: []
    # networks:
    # - name: private
    #   networks:
    #   - 10.0.0.0/8
    #   - 172.16.0.0/12
    #   - 192.168.0.0/16
    # - name: vpn
    #   networks:
    #   - 10.9.0.0/16

    rules: []
    # rules:
    # - domain: public.example.com
    #   policy: bypass
    # - domain: "*.example.com"
    #   policy: bypass
    #   methods:
    #   - OPTIONS
    # - domain: secure.example.com
    #   policy: one_factor
    #   networks:
    #   - private
    #   - vpn
    #   - 192.168.1.0/24
    #   - 10.0.0.1
    # - domain:
    #   - secure.example.com
    #   - private.example.com
    #   policy: two_factor
    # - domain: singlefactor.example.com
    #   policy: one_factor
    # - domain: "mx2.mail.example.com"
    #   subject: "group:admins"
    #   policy: deny
    # - domain: "*.example.com"
    #   subject:
    #   - "group:admins"
    #   - "group:moderators"
    #   policy: two_factor
    # - domain: dev.example.com
    #   resources:
    #   - "^/groups/dev/.*$"
    #   subject: "group:dev"
    #   policy: two_factor
    # - domain: dev.example.com
    #   resources:
    #   - "^/users/john/.*$"
    #   subject:
    #   - ["group:dev", "user:john"]
    #   - "group:admins"
    #   policy: two_factor
    # - domain: "{user}.example.com"
    #   policy: bypass

  ##
  ## Session Provider Configuration
  ##
  ## The session cookies identify the user once logged in.
  ## The available providers are: `memory`, `redis`. Memory is the provider unless redis is defined.
  session:
    ## The name of the session cookie. (default: authelia_session).
    name: authelia_session

    ## Sets the Cookie SameSite value. Possible options are none, lax, or strict.
    ## Please read https://www.authelia.com/docs/configuration/session.html#same_site
    same_site: lax

    ## The time in seconds before the cookie expires and session is reset.
    expiration: 1h

    ## The inactivity time in seconds before the session is reset.
    inactivity: 5m

    ## The remember me duration.
    ## Value is in seconds, or duration notation. Value of 0 disables remember me.
    ## See: https://www.authelia.com/docs/configuration/index.html#duration-notation-format
    ## Longer periods are considered less secure because a stolen cookie will last longer giving attackers more time to
    ## spy or attack. Currently the default is 1M or 1 month.
    remember_me_duration: 1M

    ##
    ## Redis Provider
    ##
    ## Important: Kubernetes (or HA) users must read https://www.authelia.com/docs/features/statelessness.html
    ##
    ## The redis connection details
    redis:
      enabled: false
      enabledSecret: false
      host: redis.databases.svc.cluster.local
      port: 6379

      ## Optional username to be used with authentication.
      # username: authelia
      username: ""

      ## This is the Redis DB Index https://redis.io/commands/select (sometimes referred to as database number, DB, etc).
      database_index: 0

      ## The maximum number of concurrent active connections to Redis.
      maximum_active_connections: 8

      ## The target number of idle connections to have open ready for work. Useful when opening connections is slow.
      minimum_idle_connections: 0

      ## The Redis TLS configuration. If defined will require a TLS connection to the Redis instance(s).
      tls:
        enabled: false

        ## Server Name for certificate validation (in case you are using the IP or non-FQDN in the host option).
        server_name: ""

        ## Skip verifying the server certificate (to allow a self-signed certificate).
        ## In preference to setting this we strongly recommend you add the public portion of the certificate to the
        ## certificates directory which is defined by the `certificates_directory` option at the top of the config.
        skip_verify: false

        ## Minimum TLS version for the connection.
        minimum_version: TLS1.2

      ## The Redis HA configuration options.
      ## This provides specific options to Redis Sentinel, sentinel_name must be defined (Master Name).
      high_availability:
        enabled: false
        enabledSecret: false
        ## Sentinel Name / Master Name
        sentinel_name: mysentinel

        ## The additional nodes to pre-seed the redis provider with (for sentinel).
        ## If the host in the above section is defined, it will be combined with this list to connect to sentinel.
        ## For high availability to be used you must have either defined; the host above or at least one node below.
        nodes: []
        # nodes:
        #   - host: sentinel-0.databases.svc.cluster.local
        #     port: 26379
        #   - host: sentinel-1.databases.svc.cluster.local
        #     port: 26379

        ## Choose the host with the lowest latency.
        route_by_latency: false

        ## Choose the host randomly.
        route_randomly: false

  ##
  ## Regulation Configuration
  ##
  ## This mechanism prevents attackers from brute forcing the first factor. It bans the user if too many attempts are done
  ## in a short period of time.
  regulation:
    ## The number of failed login attempts before user is banned. Set it to 0 to disable regulation.
    max_retries: 3

    ## The time range during which the user can attempt login before being banned. The user is banned if the
    ## authentication failed 'max_retries' times in a 'find_time' seconds window. Find Time accepts duration notation.
    ## See: https://www.authelia.com/docs/configuration/index.html#duration-notation-format
    find_time: 2m

    ## The length of time before a banned user can login again. Ban Time accepts duration notation.
    ## See: https://www.authelia.com/docs/configuration/index.html#duration-notation-format
    ban_time: 5m


  ##
  ## Storage Provider Configuration
  ##
  ## The available providers are: `local`, `mysql`, `postgres`. You must use one and only one of these providers.
  storage:
    ##
    ## Local (Storage Provider)
    ##
    ## This stores the data in a SQLite3 Database.
    ## This is only recommended for lightweight non-stateful installations.
    ##
    ## Important: Kubernetes (or HA) users must read https://www.authelia.com/docs/features/statelessness.html
    ##
    local:
      enabled: true
      path: /config/db.sqlite3

    ##
    ## MySQL (Storage Provider)
    ##
    ## Also supports MariaDB
    ##
    mysql:
      enabled: false
      host: mysql.databases.svc.cluster.local
      port: 3306
      database: authelia
      username: authelia

    ##
    ## PostgreSQL (Storage Provider)
    ##
    postgres:
      enabled: false
      host: 127.0.0.1
      port: 5432
      database: authelia
      username: authelia
      sslmode: disable

  ##
  ## Notification Provider
  ##
  ##
  ## Notifications are sent to users when they require a password reset, a u2f registration or a TOTP registration.
  ## The available providers are: filesystem, smtp. You must use one and only one of these providers.
  notifier:
    ## You can disable the notifier startup check by setting this to true.
    disable_startup_check: false

    ##
    ## File System (Notification Provider)
    ##
    ## Important: Kubernetes (or HA) users must read https://www.authelia.com/docs/features/statelessness.html
    ##
    filesystem:
      enabled: true
      filename: /config/notification.txt

    ##
    ## SMTP (Notification Provider)
    ##
    ## Use a SMTP server for sending notifications. Authelia uses the PLAIN or LOGIN methods to authenticate.
    ## [Security] By default Authelia will:
    ##   - force all SMTP connections over TLS including unauthenticated connections
    ##      - use the disable_require_tls boolean value to disable this requirement
    ##        (only works for unauthenticated connections)
    ##   - validate the SMTP server x509 certificate during the TLS handshake against the hosts trusted certificates
    ##     (configure in tls section)
    smtp:
      enabled: false
      enabledSecret: false
      username: test
      host: smtp.mail.svc.cluster.local
      port: 25
      sender: admin@example.com
      ## HELO/EHLO Identifier. Some SMTP Servers may reject the default of localhost.
      identifier: localhost
      ## Subject configuration of the emails sent.
      ## {title} is replaced by the text from the notifier
      subject: "[Authelia] {title}"
      ## This address is used during the startup check to verify the email configuration is correct.
      ## It's not important what it is except if your email server only allows local delivery.
      startup_check_address: test@authelia.com
      disable_require_tls: false
      disable_html_emails: false

      tls:
        ## Server Name for certificate validation (in case you are using the IP or non-FQDN in the host option).
        server_name: ""

        ## Skip verifying the server certificate (to allow a self-signed certificate).
        ## In preference to setting this we strongly recommend you add the public portion of the certificate to the
        ## certificates directory which is defined by the `certificates_directory` option at the top of the config.
        skip_verify: false

        ## Minimum TLS version for either StartTLS or SMTPS.
        minimum_version: TLS1.2

  identity_providers:
    oidc:
      ## Enables this in the config map. Currently in beta stage.
      enabled: false
      clients: []
      # - id: myapp
        # description: My Application
        ## Secret shared between client and OP.
        # secret: apple123
        ## Authorization Policy is either one_factor or two_factor.
        # authorization_policy: two_factor
        ## List of valid redirect URIs
        # redirect_uris:
        # - https://oidc.example.com/oauth2/callback
        # scopes:
        # - openid
        # - profile
        # - email
        # - groups
        # grant_types:
        # - refresh_token
        # - authorization_code
        # response_types:
        # - code

##
## Authelia Secret Generator.
##
## If both the values and existingSecret are not defined, this chart randomly generates a new secret on each
## install. It is recommended that you use something like sealed-secrets (https://github.com/bitnami-labs/sealed-secrets)
## and use the existingSecrets. All secrets can be stored in a single k8s secret if desired using the key option.
##
secret:
  existingSecret: ""
  # existingSecret: authelia

  annotations: {}
  # annotations:
  #   myAnnotation: myValue

  labels: {}
  # labels:
  #   myLabel: myValue

  mountPath: /secrets

  ## Secrets.
  jwt:
    key: JWT_TOKEN
    value: ""
    filename: JWT_TOKEN
  ldap:
    key: LDAP_PASSWORD
    value: ""
    filename: LDAP_PASSWORD
  storage:
    key: STORAGE_PASSWORD
    value: ""
    filename: STORAGE_PASSWORD
  session:
    key: SESSION_ENCRYPTION_KEY
    value: ""
    filename: SESSION_ENCRYPTION_KEY
  duo:
    key: DUO_API_KEY
    value: ""
    filename: DUO_API_KEY
  redis:
    key: REDIS_PASSWORD
    value: ""
    filename: REDIS_PASSWORD
  redisSentinel:
    key: REDIS_SENTINEL_PASSWORD
    value: ""
    filename: REDIS_SENTINEL_PASSWORD
  smtp:
    key: SMTP_PASSWORD
    value: ""
    filename: SMTP_PASSWORD
  oidcPrivateKey:
    key: OIDC_PRIVATE_KEY
    value: ""
    filename: OIDC_PRIVATE_KEY
  oidcHMACSecret:
    key: OIDC_HMAC_SECRET
    value: ""
    filename: OIDC_HMAC_SECRET

  ## HashiCorp Vault Injector configuration.
  vaultInjector:

    ## Enable the vault injector annotations. This will disable secret injection via other means.
    ## To see the annotations and what they do see: https://www.vaultproject.io/docs/platform/k8s/injector/annotations
    ## Annotations with a blank string do not get configured at all.
    ## Additional annotations can be configured via the secret.annotations: {} above.
    ## Secrets are by default rendered in the /secrets directory. Changing this can be done via editing the
    ## secret.mountPath value. You can alter the filenames with the secret.<secretName>.filename values.
    ## Secrets are loaded from vault path specified below with secrets.<secretName>.path values. Its format should be
    ## <SECRET_PATH>:<KEY_NAME>.
    ## Secrets are by default rendered by template suitable for vault KV v1 or database secrets engines. If other used,
    ## it can be overriden per each secret by specifying secrets.<secretName>.templateValue. For example for KV v2
    ## secrets engine would be '{{ with secret "<SECRET_PATH>" }}{{ .Data.data.<KEY_NAME> }}{{ end }}'.
    enabled: false

    ## The vault role to assign via annotations.
    ## Annotation: vault.hashicorp.com/role
    role: authelia

    agent:
      ## Annotation: vault.hashicorp.com/agent-inject-status
      status: update

      ## Annotation: vault.hashicorp.com/agent-configmap
      configMap: ""

      ## Annotation: vault.hashicorp.com/agent-image
      image: ""

      ## Annotation: vault.hashicorp.com/agent-init-first
      initFirst: "false"

      ## Annotation: vault.hashicorp.com/agent-inject-command
      command: "sh -c 'kill HUP $(pidof authelia)'"

      ## Annotation: vault.hashicorp.com/agent-run-as-same-user
      runAsSameUser: "true"

    secrets:
      jwt:
        ## Vault Path to the Authelia JWT secret.
        ## Annotation: vault.hashicorp.com/agent-inject-secret-jwt
        path: secrets/authelia/jwt:token

        ## Vault template specific to JWT.
        ## Annotation: vault.hashicorp.com/agent-inject-template-jwt
        templateValue: ""

        ## Vault after render command specific to JWT.
        ## Annotation: vault.hashicorp.com/agent-inject-command-jwt
        command: ""
      ldap:
        ## Vault Path to the Authelia LDAP secret.
        ## Annotation: vault.hashicorp.com/agent-inject-secret-ldap
        path: secrets/authelia/ldap:password

        ## Vault template specific to LDAP.
        ## Annotation: vault.hashicorp.com/agent-inject-template-ldap
        templateValue: ""

        ## Vault after render command specific to LDAP.
        ## Annotation: vault.hashicorp.com/agent-inject-command-ldap
        command: ""
      storage:
        ## Vault Path to the Authelia storage secret.
        ## Annotation: vault.hashicorp.com/agent-inject-secret-storage
        path: secrets/authelia/storage:password

        ## Vault template specific to storage.
        ## Annotation: vault.hashicorp.com/agent-inject-template-storage
        templateValue: ""

        ## Vault after render command specific to storage.
        ## Annotation: vault.hashicorp.com/agent-inject-command-storage
        command: ""
      session:
        ## Vault Path to the Authelia session secret.
        ## Annotation: vault.hashicorp.com/agent-inject-secret-session
        path: secrets/authelia/session:encryption_key

        ## Vault template specific to session.
        ## Annotation: vault.hashicorp.com/agent-inject-template-session
        templateValue: ""

        ## Vault after render command specific to session.
        ## Annotation: vault.hashicorp.com/agent-inject-command-session
        command: ""
      duo:
        ## Vault Path to the Authelia duo secret.
        ## Annotation: vault.hashicorp.com/agent-inject-secret-duo
        path: secrets/authelia/duo:api_key

        ## Vault template specific to duo.
        ## Annotation: vault.hashicorp.com/agent-inject-template-duo
        templateValue: ""

        ## Vault after render command specific to duo.
        ## Annotation: vault.hashicorp.com/agent-inject-command-duo
        command: ""
      redis:
        ## Vault Path to the Authelia redis secret.
        ## Annotation: vault.hashicorp.com/agent-inject-secret-redis
        path: secrets/authelia/redis:password

        ## Vault template specific to redis.
        ## Annotation: vault.hashicorp.com/agent-inject-template-redis
        templateValue: ""

        ## Vault after render command specific to redis.
        ## Annotation: vault.hashicorp.com/agent-inject-command-redis
        command: ""
      redisSentinel:
        ## Vault Path to the Authelia redis sentinel secret.
        ## Annotation: vault.hashicorp.com/agent-inject-secret-redis-sentinel
        path: secrets/authelia/redis_sentinel:password

        ## Vault template specific to redis sentinel.
        ## Annotation: vault.hashicorp.com/agent-inject-template-redis-sentinel
        templateValue: ""

        ## Vault after render command specific to redis sentinel.
        ## Annotation: vault.hashicorp.com/agent-inject-command-redis-sentinel
        command: ""
      smtp:
        ## Vault Path to the Authelia SMTP secret.
        ## Annotation: vault.hashicorp.com/agent-inject-secret-smtp
        path: secrets/authelia/smtp:password

        ## Vault template specific to SMTP.
        ## Annotation: vault.hashicorp.com/agent-inject-template-smtp
        templateValue: ""

        ## Vault after render command specific to SMTP.
        ## Annotation: vault.hashicorp.com/agent-inject-command-smtp
        command: ""
      oidcPrivateKey:
        ## Vault Path to the Authelia OIDC private key secret.
        ## Annotation: vault.hashicorp.com/agent-inject-secret-oidc-private-key
        path: secrets/authelia/oidc:private_key

        ## Vault template specific to OIDC private key.
        ## Annotation: vault.hashicorp.com/agent-inject-template-oidc-private-key
        templateValue: ""

        ## Vault after render command specific to OIDC private key.
        ## Annotation: vault.hashicorp.com/agent-inject-command-oidc-private-key
        command: ""
      oidcHMACSecret:
        ## Vault Path to the Authelia OIDC HMAC secret.
        ## Annotation: vault.hashicorp.com/agent-inject-secret-oidc-hmac-secret
        path: secrets/authelia/oidc:hmac_secret

        ## Vault template specific to OIDC HMAC secret.
        ## Annotation: vault.hashicorp.com/agent-inject-template-oidc-hmac-secret
        templateValue: ""

        ## Vault after render command specific to OIDC HMAC secret.
        ## Annotation: vault.hashicorp.com/agent-inject-command-oidc-hmac-secret
        command: ""

certificates:
  existingSecret: ""
  # existingSecret: authelia

  annotations: {}
  # annotations:
  #   myAnnotation: myValue

  labels: {}
  # labels:
  #   myLabel: myValue

  values: {}
  # values:
  # - name: Example_Com_Root_Certificate_Authority_B64.pem
  #   secretValue: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURYekNDQWtlZ0F3SUJBZ0lMQkFBQUFBQUJJVmhUQ0tJd0RRWUpLb1pJaHZjTkFRRUxCUUF3VERFZ01CNEcKQTFVRUN4TVhSMnh2WW1Gc1UybG5iaUJTYjI5MElFTkJJQzBnVWpNeEV6QVJCZ05WQkFvVENrZHNiMkpoYkZOcApaMjR4RXpBUkJnTlZCQU1UQ2tkc2IySmhiRk5wWjI0d0hoY05NRGt3TXpFNE1UQXdNREF3V2hjTk1qa3dNekU0Ck1UQXdNREF3V2pCTU1TQXdIZ1lEVlFRTEV4ZEhiRzlpWVd4VGFXZHVJRkp2YjNRZ1EwRWdMU0JTTXpFVE1CRUcKQTFVRUNoTUtSMnh2WW1Gc1UybG5iakVUTUJFR0ExVUVBeE1LUjJ4dlltRnNVMmxuYmpDQ0FTSXdEUVlKS29aSQpodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU13bGRwQjVCbmdpRnZYQWc3YUV5aWllL1FWMkVjV3RpSEw4ClJnSkR4N0tLblFSZkpNc3VTK0ZnZ2tiaFVxc01nVWR3Yk4xazBldjFMS01QZ2owTUs2NlgxN1lVaGhCNXV6c1QKZ0hlTUNPRkowbXBpTHg5ZStwWm8zNGtubFRpZkJ0Yyt5Y3NtV1ExejNyREk2U1lPZ3hYRzcxdUwwZ1JneWttbQpLUFpwTy9iTHlDaVI1WjJLWVZjM3JIUVUzSFRnT3U1eUx5NmMrOUM3di9VOUFPRUdNK2lDSzY1VHBqb1djNHpkClFRNGdPc0MwcDZIcHNrK1FMakpnNlZmTHVRU1NhR2psT0NaZ2RiS2ZkLytSRk8rdUlFbjhyVUFWU05FQ01XRVoKWHJpWDc2MTN0MlNhZXI5ZndSUHZtMkw3RFd6Z1ZHa1dxUVBhYnVtRGszRjJ4bW1GZ2hjQ0F3RUFBYU5DTUVBdwpEZ1lEVlIwUEFRSC9CQVFEQWdFR01BOEdBMVVkRXdFQi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZJL3dTMytvCkxrVWtyazFRK21PYWk5N2kzUnU4TUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFCTFFOdkFVS3IreUF6djk1WlUKUlVtN2xnQUpRYXl6RTRhR0tBY3p5bXZtZExtNkFDMnVwQXJUOWZIeEQ0cS9jMmRLZzhkRWUzamdyMjVzYndNcApqak01UmNPTzVMbFhiS3I4RXBic1U4WXQ1Q1JzdVpSais5eFRhR2RXUG9PNHp6VWh3OGxvL3M3YXdsT3F6SkNLCjZmQmRSb3lWM1hwWUtCb3ZIZDdOQURkQmorMUViZGRUS0pkKzgyY0VIaFhYaXBhMDA5NU1KNlJNRzNOemR2UVgKbWNJZmVnN2pMUWl0Q2h3cy96eXJWUTRQa1g0MjY4TlhTYjdoTGkxOFlJdkRRVkVUSTUzTzl6SnJsQUdvbWVjcwpNeDg2T3lYU2hrRE9PeXlHZU1saEx4UzY3dHRWYjkrRTdnVUpUYjBvMkhMTzAySlFaUjdya3BlRE1kbXp0Y3BICldEOWYKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ==
  # - name: Example_Com_Root_Certificate_Authority.pem
  #   value: |
  #     -----BEGIN CERTIFICATE-----
  #     MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
  #     A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
  #     Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
  #     MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
  #     A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
  #     hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
  #     RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
  #     gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
  #     KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
  #     QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
  #     XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
  #     DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
  #     LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
  #     RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
  #     jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
  #     6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
  #     mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
  #     Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
  #     WD9f
  #     -----END CERTIFICATE-----

##
## Authelia Persistence Configuration.
##
## Useful in scenarios where you need persistent storage.
## Auth Provider Use Case: file; we recommend you use the ldap provider instead.
## Storage Provider Use Case: local; we recommend you use the mysql/mariadb or postgres provider instead.
## Configuration Use Case: when you want to manually configure the configuration entirely (set configMap.enabled = false).
##
persistence:
  enabled: false

  annotations: {}
  # annotations:
  #   myAnnotation: myValue

  labels: {}
  # labels:
  #   myLabel: myValue

  readOnly: false
  subPath: ""

  existingClaim: ""
  # existingClaim: my-claim-name

  storageClass: ""
  # storageClass: "my-storage-class"

  accessModes:
    - ReadWriteOnce

  size: 100Mi

  selector: {}
...
